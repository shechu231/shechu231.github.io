
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>nacos入门 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="测试文件地址
注册中心简介背景分析在微服务中，首先需要面对的问题就是如何查找服务(软件即服务)，其次,就是如何在不同的服务之间进行通信？如何更好更方便的管理应用中的每一个服务，如何建立各个服务之间联,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="nacos入门 - Hexo"/>
    <meta name="twitter:description" content="测试文件地址
注册中心简介背景分析在微服务中，首先需要面对的问题就是如何查找服务(软件即服务)，其次,就是如何在不同的服务之间进行通信？如何更好更方便的管理应用中的每一个服务，如何建立各个服务之间联,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="nacos入门 - Hexo"/>
    <meta property="og:description" content="测试文件地址
注册中心简介背景分析在微服务中，首先需要面对的问题就是如何查找服务(软件即服务)，其次,就是如何在不同的服务之间进行通信？如何更好更方便的管理应用中的每一个服务，如何建立各个服务之间联,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">nacos入门</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">nacos入门</h1>
        <div class="stuff">
            <span>十二月 23, 2021</span>
            

        </div>
        <div class="content markdown">
            <p><a target="_blank" rel="noopener" href="https://gitee.com/the-world-is-new/three-part">测试文件地址</a></p>
<h1 id="注册中心简介"><a href="#注册中心简介" class="headerlink" title="注册中心简介"></a>注册中心简介</h1><p>背景分析<br>在微服务中，首先需要面对的问题就是如何查找服务(软件即服务)，其次,就是如何在不同的服务之间进行通信？如何更好更方便的管理应用中的每一个服务，如何建立各个服务之间联系的纽带，由此注册中心诞生（例如淘宝网卖家提供服务，买家调用服务）。<br>市面上常用注册中心有Zookeeper(雅虎Apache),Eureka(Netfix),Nacos(Alibaba),Consul(Google),那他们分别都有什么特点，我们如何进行选型呢？我们主要从社区活跃度,稳定性,功能,性能等方面进行考虑即可.本次微服务的学习,我们选择Nacos,它很好的支持了阿里的双11活动,不仅可以做注册中心，还可以作为配置中心，稳定性和性能都很好。</p>
<h1 id="构建Nacos服务"><a href="#构建Nacos服务" class="headerlink" title="构建Nacos服务"></a>构建Nacos服务</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>第一：确保你电脑已配置JAVA_HOME环境变量(Nacos启动时需要)</p>
<p>第二：确保你的MySQL版本为5.7以上（MariaDB10.5以上)</p>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>第一步：Nacos下载,可在浏览器直接输入如下地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
<p><img src="https://img-blog.csdnimg.cn/5c366dd1cf2442568e182a2ae13dd2a2.png" alt="在这里插入图片描述"></p>
<p>第三步：解压Nacos（最好不要解压到中文目录下），其目录结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/8d139f02efdf46f48a97179bde2d0f20.png" alt="在这里插入图片描述"></p>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>第一步：打开操作系统命令行，登陆mysql，执行课前资料中的sql脚本，不是nacos/conf目录下自带的。<br>例如,我们可以使用mysql自带客户端,在命令行首先登录mysql,然后执行如下指令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> d:/nacos-mysql.sql </span><br></pre></td></tr></table></figure>

<p>会有一个表nacos_config</p>
<p>第二步：打开/nacos/conf/application.properties里打开默认配置，并基于你当前环境配置要连接的数据库，连接数据库时使用的用户名和密码(假如前面有”#”要将其去掉)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">###If use MySQL as datasource:</span><br><span class="line"></span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">###Count of DB:</span><br><span class="line"></span><br><span class="line">db.num=1</span><br><span class="line"></span><br><span class="line">###Connect URL of DB:</span><br><span class="line"></span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=root</span><br></pre></td></tr></table></figure>

<p>服务启动与访问<br>第一步:启动Nacos服务（nacos的bin目录去通过指令启动）。</p>
<p>​        Linux/Unix/Mac启动命令(standalone代表着单机模式运行，非集群模式):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>​        Windows启动命令(standalone代表着单机模式运行，非集群模式):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>第二步:访问Nacos服务。</p>
<p>打开浏览器，输入<a target="_blank" rel="noopener" href="http://localhost:8848/nacos%E5%9C%B0%E5%9D%80">http://localhost:8848/nacos地址</a></p>
<p>其中，默认账号密码为nacos/nacos.</p>
<h1 id="服务注册与调用入门（重点）"><a href="#服务注册与调用入门（重点）" class="headerlink" title="服务注册与调用入门（重点）"></a>服务注册与调用入门（重点）</h1><h2 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h2><p>创建两个项目Module分别为服务提供者和服务消费者（假如已有则无需创建），两者都要注册到NacosServer中(这个server本质上就是一个web服务，端口默认为8848)，然后服务提供者可以为服务消费者提供远端调用服务(例如支付服务为服务提供方，订单服务为服务消费方)，如图所示：<br><img src="https://img-blog.csdnimg.cn/4421daf970c54d658be898ace0b09c73.png" alt="在这里插入图片描述"></p>
<h2 id="生产者服务创建及注册"><a href="#生产者服务创建及注册" class="headerlink" title="生产者服务创建及注册"></a>生产者服务创建及注册</h2><p>父工程maven的pom.xml配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;sca-consumer&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;sca-gateway&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;sca-provider&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;sca-common&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--统一依赖版本(spring boot,spring cloud,spring cloud alibaba)</span><br><span class="line">注意，这里只做版本管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--Spring Boot--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;&lt;!--允许scope的值为import时，type的值必须pom--&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt; &lt;!--这里的import类似java中的import--&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Spring Cloud (Spring Cloud 工程依赖于spring boot)，</span><br><span class="line">        spring cloud中定义的是一些微服务规范。--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;Hoxton.SR9&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Spring Cloud Alibaba (这套依赖是基于Spring Cloud规范，做了具体的落地实现)--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line">&lt;!--定义公共依赖(lombok,test)--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;!--springboot 2.2以后版本默认单元测试使用的是junit5，</span><br><span class="line">            所以junit4以前的测试引擎不在需要--&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;!--定义统一编译运行环境(jdk)--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;!--定义maven的编译插件--&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;8&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>添加依赖:</p>
<pre><code>&lt;dependencies&gt;
    &lt;!--Web服务--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--服务的注册和发现(我们要讲服务注册到nacos)--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>第二步：创建并修改配置文件application.yml(或者application.properties)，实现服务注册，关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">   port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-provider #进行服务注册必须配置服务名</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br></pre></td></tr></table></figure>

<p>第三步：创建启动类(假如已有则无需定义)，关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.jt;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ProviderApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：启动启动类，然后刷先nacos服务，检测是否服务注册成功，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/1ba763e2644440efbc5f46f3762f6533.png" alt="在这里插入图片描述"></p>
<p>第五步:停掉sca-provider服务，然后不断刷新nacos服务列表，检查服务的健康状态。</p>
<h2 id="消费者服务发现及调用"><a href="#消费者服务发现及调用" class="headerlink" title="消费者服务发现及调用"></a>消费者服务发现及调用</h2><p>第一步: 在sca-provider项目中创建服务提供方对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.provider.controller;</span><br><span class="line">   /**定义Controller对象(这个对象在spring mvc中给他的定义是handler),</span><br><span class="line">    * 基于此对象处理客户端的请求*/</span><br><span class="line">   @RestController</span><br><span class="line">   public class ProviderController&#123;</span><br><span class="line">       //@Value默认读取项目配置文件中配置的内容</span><br><span class="line">       //8080为没有读到server.port的值时,给定的默认值</span><br><span class="line">       @Value(&quot;$&#123;server.port:8080&#125;&quot;)</span><br><span class="line">       private String server;</span><br><span class="line">       //http://localhost:8081/provider/echo/tedu</span><br><span class="line">       @GetMapping(&quot;/provider/echo/&#123;msg&#125;&quot;)</span><br><span class="line">       public String doRestEcho1(@PathVariable String msg)&#123;</span><br><span class="line">           return server+&quot; say hello &quot;+msg;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>第二步：创建服务消费者工程（module名为sca-consumer，假如已有则无需创建），继承parent工程（01-sca），其pom.xml文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;artifactId&gt;sca-consumer&lt;/artifactId&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">    &lt;!--Web服务--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--服务的注册和发现(我们要讲服务注册到nacos)--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>第三步：创建sca-consumer服务中的配置文件application.yml，关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8090</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-consumer #服务注册时，服务名必须配置</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #从哪里去查找服务</span><br></pre></td></tr></table></figure>

<p>第四步：创建消费端启动类并实现服务消费，关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.jt;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步:在sca-consumer启动类中添加如下方法,用于创建RestTemplate对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Bean public RestTemplate restTemplate()&#123;*//基于此对象实现远端服务调用*    return new RestTemplate(); &#125;</span><br></pre></td></tr></table></figure>

<p>第六步:定义sca-consumer服务的消费端Controller,在此对象方法内部实现远端服务调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.consumer.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * 定义服务消费端Controller,在这个Controller对象</span><br><span class="line"> * 的方法中实现对远端服务sca-provider的调用</span><br><span class="line">   */</span><br><span class="line">   @RestController</span><br><span class="line">   public class ConsumerController &#123;</span><br><span class="line">   /**</span><br><span class="line">    * 从spring容器获取一个RestTemplate对象,</span><br><span class="line">    * 基于此对象实现远端服务调用</span><br><span class="line">      */</span><br><span class="line">      @Autowired</span><br><span class="line">      private RestTemplate restTemplate;</span><br><span class="line">      /**</span><br><span class="line">    * 在此方法中通过一个RestTemplate对象调用远端sca-provider中的服务</span><br><span class="line">    * @return</span><br><span class="line">    * 访问此方法的url: http://localhost:8090/consumer/doRestEcho1</span><br><span class="line">      */</span><br><span class="line">      @GetMapping(&quot;/consumer/doRestEcho1&quot;)</span><br><span class="line">      public String doRestEcho01()&#123;</span><br><span class="line">      //1.定义要调用的远端服务的url</span><br><span class="line">      String url=&quot;http://localhost:8081/provider/echo/8090&quot;;</span><br><span class="line">      //2.基于restTemplate对象中的相关方法进行服务调用</span><br><span class="line">      return restTemplate.getForObject(url, String.class);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第七步：启动消费者服务，并在浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8090/consumer/doRestEcho1%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95%E3%80%82">http://localhost:8090/consumer/doRestEcho1地址进行访问测试。</a></p>
<h1 id="服务负载均衡设计及实现（重点）"><a href="#服务负载均衡设计及实现（重点）" class="headerlink" title="服务负载均衡设计及实现（重点）"></a>服务负载均衡设计及实现（重点）</h1><p>业务描述<br>一个服务实例可以处理请求是有限的,假如服务实例的并发访问比较大,我们会启动多个服务实例,让这些服务实例采用一定策略均衡(轮询,权重,随机,hash等)的处理并发请求,在Nacos中服务的负载均衡(Nacos客户端负载均衡)是如何应用的?</p>
<p>LoadBalancerClient应用<br>LoadBalancerClient对象可以从nacos中基于服务名获取服务实例，然后在工程中基于特点算法实现负载均衡方式的调用，案例实现如下：</p>
<p>第一步:修改ConsumerController类,注入LoadBalancerClient对象,并添加doRestEcho2方法,然后进行服务访问.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">  private LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">  @Value(&quot;$&#123;spring.application.name:8090&#125;&quot;)</span><br><span class="line">  private String appName;</span><br><span class="line"></span><br><span class="line">  @GetMapping(&quot;/consumer/doRestEcho02&quot;)</span><br><span class="line"> public String doRestEcho02()&#123;</span><br><span class="line">     ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;sca-provider&quot;);</span><br><span class="line">     String url = String.format(&quot;http://%s:%s/provider/echo/%s&quot;,serviceInstance.getHost(),serviceInstance.getPort(),appName);</span><br><span class="line">     System.out.println(&quot;request url:&quot;+url);</span><br><span class="line">     return restTemplate.getForObject(url, String.class);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>第二步：打开Idea服务启动配置，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/fd5b4ccc3ed64e3f9db36562548fd02e.png" alt="在这里插入图片描述"></p>
<p>第四步：修改sca-provider的配置文件端口，分别以8081，8082端口方式进行启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br></pre></td></tr></table></figure>

<p>第五步：启动成功以后，访问nacos的服务列表，检测服务是否成功注册，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/61f5fe11dbe74d0088bad185a8b25b37.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/50a56d6d947e4b18a0adec0ba867f4a7.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/efb6499e92904cbea7653f61082e639b.png" alt="在这里插入图片描述"></p>
<p>第六步：启动sca-consumer项目模块，打开浏览器对consumer服务进行访问，访问时不断刷新，检测页面数据变化。</p>
<p>说明，这里多个实例并发提供服务的方式为负载均衡，这里的负载均衡实现默认是因为Nacos集成了Ribbon来实现的，Ribbon配合RestTemplate，可以非常容易的实现服务之间的访问。Ribbon是Spring Cloud核心组件之一，它提供的最重要的功能就是客户端的负载均衡(客户端可以采用一定算法,例如轮询访问，访问服务端实例信息)，这个功能可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡方式的服务调用。</p>
<h2 id="LoadBalanced"><a href="#LoadBalanced" class="headerlink" title="@LoadBalanced"></a>@LoadBalanced</h2><p>当使用RestTemplate进行远程服务调用时，假如需要负载均衡,还可以在RestTemplate对象构建时，使用@LoadBalanced对构建RestTemplate的方法进行修饰，例如在ConsumerApplication中构建名字为loadBalancedRestTemplate的RestTemplate对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate loadBalancedRestTemplate()&#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要RestTemplate实现负载均衡调用的地方进行依赖注入.例如在ConsumerController类中添加loadBalancedRestTemplate属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestTemplate loadBalancedRestTemplate;</span><br></pre></td></tr></table></figure>

<p>接下来，可以在对应的服务端调用方的方法内，基于RestTemplate借助服务名进行服务调用， 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/consumer/doRestEcho3&quot;)</span><br><span class="line">public String doRestEcho03()&#123;</span><br><span class="line">    String url=String.format(&quot;http://%s/provider/echo/%s&quot;,&quot;sca-provider&quot;,appName);</span><br><span class="line">    //向服务提供方发起http请求,获取响应数据</span><br><span class="line">    return loadBalancedRestTemplate.getForObject(</span><br><span class="line">            url,//要请求的服务的地址</span><br><span class="line">            String.class);//String.class为请求服务的响应结果类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RestTemplate在发送请求的时候会被LoadBalancerInterceptor拦截，它的作用就是用于RestTemplate的负载均衡，LoadBalancerInterceptor将负载均衡的核心逻辑交给了loadBalancer，核心代码如下所示(了解):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ClientHttpResponse intercept(final HttpRequest request, </span><br><span class="line">    final byte[] body, final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">	final URI originalUri = request.getURI();</span><br><span class="line">	String serviceName = originalUri.getHost();</span><br><span class="line">	return this.loadBalancer.execute(serviceName, </span><br><span class="line">    requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@LoadBalanced注解是属于Spring，而不是Ribbon的，Spring在初始化容器的时候，如果检测到Bean被@LoadBalanced注解，Spring会为其设置LoadBalancerInterceptor的拦截器。</p>
<h2 id="Ribbon负载均衡策略-了解"><a href="#Ribbon负载均衡策略-了解" class="headerlink" title="Ribbon负载均衡策略(了解)"></a>Ribbon负载均衡策略(了解)</h2><p>基于Ribbon方式的负载均衡，Netflix默认提供了七种负载均衡策略，对于SpringCloud Alibaba解决方案中又提供了NacosRule策略，默认的负载均衡策略是轮训策略。如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/fb4e370978ad467b90ea81ca176f179e.png" alt="在这里插入图片描述"></p>
<p>当系统提供的负载均衡策略不能满足我们需求时，我们还可以基于IRule接口自己定义策略.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public IRule rule()&#123;</span><br><span class="line">return new RandomRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">底层默认逻辑实现，@ConditionalOnMissingBean注解配合@Bean注解一起使用时，</span><br><span class="line">会在没有指定Bean时，才去创建这个Bean对象。</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(IRule.class)</span><br><span class="line">public IRule rule()&#123;</span><br><span class="line">return new BestAvailableRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">小节面试分析</span><br><span class="line">@Bean注解的作用?(一般用于配置类内部,描述相关方法,用于告诉spring此方法的返回值要交给spring管理,bean的名字默认为方法名,假如需要指定名字可以@Bean(“bean的名字”),最多的应用场景是整合第三方的资源-对象)</span><br><span class="line">@Autowired注解的作用?(此注解用于描述属性,构造方法,set方法等,用于告诉spring框架,按找一定的规则为属性进行DI操作,默认按属性,方法参数类型查找对应的对象,假如只找到一个,则直接注入,类型多个时还会按照属性名或方法参数名进行值的注入,假如名字也不同,就出报错.)</span><br><span class="line">Nacos中的负责均衡底层是如何实现的?(通过Ribbon实现,Ribbon中定义了一些负载均衡算法,然后基于这些算法从服务实例中获取一个实例为消费方法提供服务)</span><br><span class="line">Ribbon 是什么？(Netflix公司提供的负载均衡客户端,一般应用于服务的消费方法)</span><br><span class="line">Ribbon 可以解决什么问题? (基于负载均衡策略进行服务调用, 所有策略都会实现IRule接口)</span><br><span class="line">Ribbon 内置的负载策略都有哪些?(8种,可以通过查看IRule接口的实现类进行分析)</span><br><span class="line">@LoadBalanced的作用是什么？(描述RestTemplate对象,用于告诉Spring框架，在使用RestTempalte进行服务调用时，这个调用过程会被一个拦截器进行拦截,然后在拦截器内部,启动负载均衡策略。)</span><br><span class="line">我们可以自己定义负载均衡策略吗？(可以，基于IRule接口进行策略定义,也可以参考NacosRule进行实现)</span><br></pre></td></tr></table></figure>

<p>拓展:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#sca-provider服务的负载均衡配置</span><br><span class="line">sca-provider:</span><br><span class="line">  ribbon: #ribbon是一个负载均衡组件，是Ribbon组件中提供了IRule接口及相关实现</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>



<h1 id="基于Feign的远程服务调用（重点）"><a href="#基于Feign的远程服务调用（重点）" class="headerlink" title="基于Feign的远程服务调用（重点）"></a>基于Feign的远程服务调用（重点）</h1><h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><p>服务消费方基于rest方式请求服务提供方的服务时，一种直接的方式就是自己拼接url，拼接参数然后实现服务调用，但每次服务调用都需要这样拼接，代码量复杂且不易维护，此时Feign诞生。</p>
<h2 id="Feign是什么"><a href="#Feign是什么" class="headerlink" title="Feign是什么"></a>Feign是什么</h2><p>Feign 是一种声明式Web服务客户端，底层封装了对Rest技术的应用,通过Feign可以简化服务消费方对远程服务提供方法的调用实现。如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/163741e4cff44e7aa714bb003c9b2672.png" alt="在这里插入图片描述"></p>
<p>Feign 最早是由 Netflix 公司进行维护的，后来 Netflix 不再对其进行维护，最终 Feign 由一些社区进行维护，更名为 OpenFeign。</p>
<h2 id="Feign应用实践（掌握）"><a href="#Feign应用实践（掌握）" class="headerlink" title="Feign应用实践（掌握）"></a>Feign应用实践（掌握）</h2><p>第一步：在服务消费方，添加项目依赖(SpringCloud团队基于OpenFeign研发了starter)，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：在启动类上添加@EnableFeignClients注解，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;…&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：定义Http请求API，基于此API借助OpenFeign访问远端服务，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.consumer.service;</span><br><span class="line">@FeignClient(name=&quot;sca-provider&quot;)//sca-provider为服务提供者名称</span><br><span class="line">public interface RemoteProviderService&#123;</span><br><span class="line">    @GetMapping(&quot;/provider/echo/&#123;string&#125;&quot;)//前提是远端需要有这个服务</span><br><span class="line">    public String echoMessage(@PathVariable(&quot;string&quot;) String string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，@FeignClient描述的接口底层会为其创建实现类。</p>
<p>第四步：创建FeignConsumerController中并添加feign访问，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.consumer.controller;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/consumer/ &quot;)</span><br><span class="line">public class FeignConsumerController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RemoteProviderService remoteProviderService;</span><br><span class="line">    /**基于feign方式的服务调用*/</span><br><span class="line">    @GetMapping(&quot;/echo/&#123;msg&#125;&quot;)</span><br><span class="line">    public String doFeignEcho(@PathVariable  String msg)&#123;</span><br><span class="line">        //基于feign方式进行远端服务调用(前提是服务必须存在)</span><br><span class="line">        return remoteProviderService.echoMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步：启动消费者服务，在浏览器中直接通过feign客户端进行访问，如图所示（反复刷新检测其响应结果）：</p>
<p><img src="https://img-blog.csdnimg.cn/d89e1e76746141a6bab78830a82af589.png" alt="在这里插入图片描述"></p>
<p>其启动异常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The bean &#x27;optimization-user.FeignClientSpecification&#x27;, defined in null, could not be registered. A bean with that name has already been defined in null and overriding is disabled.</span><br></pre></td></tr></table></figure>

<p>此时我们需要为远程调用服务接口指定一个contextId,作为远程调用服务的唯一标识（这个标识是Bean对象的名字）即可,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name=&quot;sca-provider&quot;,contextId=&quot;remoteProviderService&quot;)//sca-provider为服务提供者名称</span><br><span class="line">interface RemoteProviderService&#123;</span><br><span class="line">    @GetMapping(&quot;/provider/echo/&#123;string&#125;&quot;)//前提是远端需要有这个服务</span><br><span class="line">    public String echoMessage(@PathVariable(&quot;string&quot;) String string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有,当我们在进行远程服务调用时,假如调用的服务突然不可用了或者调用过程超时了,怎么办呢?一般服务消费端会给出具体的容错方案,例如，在Feign应用中通过FallbackFactory接口的实现类进行默认的相关处理，例如:</p>
<p>第一步:定义FallbackFactory接口的实现,代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.cy.service.factory;</span><br><span class="line">/**</span><br><span class="line"> * 基于此对象处理RemoteProviderService接口调用时出现的服务中断,超时等问题</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class ProviderFallbackFactory implements FallbackFactory&lt;RemoteProviderService&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 此方法会在RemoteProviderService接口服务调用时,出现了异常后执行.</span><br><span class="line">     * @param throwable 用于接收异常</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public RemoteProviderService create(Throwable throwable) &#123;</span><br><span class="line">        return (msg)-&gt;&#123;</span><br><span class="line">                return &quot;服务维护中,稍等片刻再访问&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步:在Feign访问接口中应用FallbackFactory对象,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;sca-provider&quot;, contextId = &quot;remoteProviderService&quot;,</span><br><span class="line">             fallbackFactory = ProviderFallbackFactory.class)//sca-provider为nacos中的服务名</span><br><span class="line">public interface RemoteProviderService &#123;</span><br><span class="line">    @GetMapping(&quot;/provider/echo/&#123;msg&#125;&quot;)</span><br><span class="line">    public String echoMsg(@PathVariable String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步:在配置文件application.yml中添加如下配置,启动feign方式调用时的服务中断处理机制.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:  </span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true #默认值为false</span><br></pre></td></tr></table></figure>

<p>第四步:在服务提供方对应的调用方法中添加Thread.sleep(5000)模拟耗时操作,然后启动服务进行访问测试.</p>
<h2 id="Feign-调用过程分析（了解）"><a href="#Feign-调用过程分析（了解）" class="headerlink" title="Feign 调用过程分析（了解）"></a>Feign 调用过程分析（了解）</h2><h3 id="Feign应用过程分析（底层逻辑先了解）："><a href="#Feign应用过程分析（底层逻辑先了解）：" class="headerlink" title="Feign应用过程分析（底层逻辑先了解）："></a>Feign应用过程分析（底层逻辑先了解）：</h3><p>1)通过 @EnableFeignCleints 注解告诉springcloud,启动 Feign Starter 组件。</p>
<ol start="2">
<li>Feign Starter 会在项目启动过程中注册全局配置，扫描包下所由@FeignClient注解描述的接口，然后由系统底层创建接口实现类(JDK代理类)，并构建类的对象，然后交给spring管理(注册 IOC 容器)。</li>
<li>Feign接口被调用时，底层代理对象会将接口中的请求信息通过编码器创建 Request对象，基于此对象进行远程过程调用。</li>
<li>Feign客户端请求对象会经Ribbon进行负载均衡，挑选出一个健康的 Server 实例（instance）。</li>
<li>Feign客户端会携带 Request 调用远端服务并返回一个响应。</li>
<li>Feign客户端对象对Response信息进行解析然后返回客户端。</li>
</ol>
<h2 id="小节面试分析"><a href="#小节面试分析" class="headerlink" title="小节面试分析"></a>小节面试分析</h2><p>为什么使用feign?(基于Feign可以更加友好的实现服务调用，简化服务消费方对服务提供方方法的调用)。<br>@FeignClient注解的作用是什么？(告诉Feign Starter，在项目启动时，为此注解描述的接口创建实现类-代理类)<br>Feign方式的调用，底层负载均衡是如何实现的？(Ribbon)<br>@EnableFeignCleints 注解的作用是什么？（描述配置类，例如启动类）</p>
<h2 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h2><h3 id="重难点分析"><a href="#重难点分析" class="headerlink" title="重难点分析"></a>重难点分析</h3><p>何为注册中心？(用于记录服务信息的一个web服务，例如淘宝平台，滴滴平台，美团外卖平台，……)<br>注册中心的核心对象？(服务提供方，服务消费方，注册中心-Registry)<br>市面上常用注册中心？(Google-Consul,Alibaba-Nacos,…)<br>Nacos安装、启动、服务的注册、发现机制以及实现过程<br>服务调用时RestTemplate对象的应用。<br>基于Feign方式的服务调用及基本原理？</p>
<h2 id="FAQ分析"><a href="#FAQ分析" class="headerlink" title="FAQ分析"></a>FAQ分析</h2><p>Nacos是什么，提供了什么特性(服务的注册、发现、配置)？<br>你为什么会选择Nacos?（活跃度、稳定、性能、学习成本）<br>Nacos的官网？(nacos.io)<br>Nacos在github的源码？(github.com/alibaba/nacos)<br>Nacos在windows环境下安装?(解压即可使用)<br>Nacos在windows中的的初步配置？(application.properties访问数据库的数据源)<br>Nacos服务注册的基本过程？（服务启动时发送web请求）<br>Nacos服务消费的基本过程？（服务启动时获取服务实例，然后调用服务）<br>Nacos服务负载均衡逻辑及设计实现？(Ribbon)<br>注册中心的核心数据是什么？（服务的名字和它对应的网络地址）<br>注册中心中心核心数据的存取为什么会采用读写锁?(底层安全和性能)<br>Nacos健康检查的方式？(基于心跳包机制进行实现)<br>Nacos是如何保证高可用的?(重试，本地缓存、集群)<br>RestTemplate的基本作用是什么？<br>Feign是什么，它的应用是怎样的，feign应用过程中的代理对象是如何创建的（JDK）？<br>Feign方式的调用过程，其负载均衡是如何实现？(Ribbon)<br>Bug分析<br>404  //找不到页面<br>400    //请求出错 由于语法格式有误,服务器无法理解此请求。<br>405    //Request method ‘GET’ not supported(405-用来访问本页面的HTTP方法不被允许)这是因为浏览器访问网站是GET请求，后端服务器本地址只接受POST请求。<br>500    //服务器错误</p>
<p>414    //服务器接收数据处理错误。一般controller层</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
