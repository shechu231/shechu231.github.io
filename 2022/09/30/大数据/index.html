
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>大数据 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="虚拟机配置：    密码统一：123abt    linux常用命令：        yum被占用解决:强制采用rm -f /var/run/yum.pid关闭yum进程即可
    设置开机启动：,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="大数据 - Hexo"/>
    <meta name="twitter:description" content="虚拟机配置：    密码统一：123abt    linux常用命令：        yum被占用解决:强制采用rm -f /var/run/yum.pid关闭yum进程即可
    设置开机启动：,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="大数据 - Hexo"/>
    <meta property="og:description" content="虚拟机配置：    密码统一：123abt    linux常用命令：        yum被占用解决:强制采用rm -f /var/run/yum.pid关闭yum进程即可
    设置开机启动：,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">大数据</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">大数据</h1>
        <div class="stuff">
            <span>九月 30, 2022</span>
            

        </div>
        <div class="content markdown">
            <p>虚拟机配置：<br>    密码统一：123abt<br>    linux常用命令：<br>        yum被占用解决:强制采用rm -f /var/run/yum.pid关闭yum进程即可</p>
<pre><code>    设置开机启动：
        chkconfig php-fpm on
    mysql安装：
        wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 
        rpm -ivh mysql-community-release-el7-5.noarch.rpm
        yum install mysql-server
        
    安装ifconfig命令：
        yum provides ifconfig
    查看进程：
        ps aux和ps -fe进程快照
        cd /proc/$$/fd   /proc/$pid/fd 目录下存放了此进程所有打开的fd,用ls -l查看
        /proc/net/tcp（udp对应/proc/net/udp）    如对应的&lt;本地地址：端口号，远端地址：端口号&gt;cat /proc/net/tcp
        杀死进程：kill SIGNAL PID
        
    awk命令：
        awk &#39;/0.5/ &#123;print $1,$2&#125;&#39; teams.txt  包含0.5的两列
        awk -F  #-F相当于内置变量FS, 指定分割字符
        # 使用&quot;,&quot;分割
        awk -F, &#39;&#123;print $1,$2&#125;&#39;   log.txt
        过滤第一列等于2的行
        $ awk &#39;$1==2 &#123;print $1,$3&#125;&#39; log.txt    #命令
        # 输出第二列包含 &quot;th&quot;，并打印第二列与第四列
        awk &#39;$2 ~ /th/ &#123;print $2,$4&#125;&#39; log.txt
        
    find命令：
        将目前目录及其子目录下所有延伸档名是 c 的文件列出来。
            # find . -name &quot;*.c&quot;
        查找文件
            find ./ -type f
        查找目录
            find ./ -type d
        查找名字为test的文件或目录
            find ./ -name test
        查找名字符合正则表达式的文件,注意前面的‘.*’(查找到的文件带有目录)
            find ./ -regex .*so.*\.gz
        查找空文件并删除
            find ./ -empty -type f -print -delete
        管道使用:
            find /etc -name &quot;*.conf&quot; | xargs ls -l 列出详细目录
    grep命令：
        第一个例子让我们来搜索 /etc/ 目录下所有包含 stretch 字符串的文件，但不去搜索其中的子目录:
            # grep -s stretch /etc/*
        查找指定目录
            grep -r &quot;查询内容&quot;  文件目录
        ##只显示包含内容的文件名
            grep -r -l &quot;查询内容&quot;  文件目录
        ##文件名+内容  
            find 文件目录  -type f |xargs grep &quot;查询内容&quot;; 

    创建用户名和密码：
        
        /etc/passwd，各个字段内容的含义：root:x:0:0:root:/root:/bin/bash
        用户名：x密码占位符：UID：基本组ID：用户的注释信息：家目录：用户默认shell
        ps：这里的x表示密码占位符，真正的密码在shadow中
        
        /etc/group文件格式：
        组名：密码占位符：组ID：以这个组为附加组的用户列表
        
        useradd 用户名
        -u UID
        -g GID（基本组）
        -G GID，......（附加组）
        -c “COMMENT”
        -d /path/to/directory指定家目录
        -s 指定SHELL路径
        -m -k 强制创建家目录并把/etc/skel目录下的内容复制过去
        -M 不给用户创建家目录
        # passwd tom    添加密码
        修改密码    echo &quot;123456&quot; | passwd --stdin tom
        赋予sudo权限：修改vim /etc/sudoers        xxx ALL=(ALL) ALL
        增加用户：useradd -d /usr/username -m username
        为用户增加密码：passwd username
        新建工作组：groupadd groupname
        将用户添加进工作组：usermod -G groupname username
        删除用户：userdel -r username
        
    ls命令:
        -l     详细列表的形式进行列出
        -h     以较高可读性列出
        ls -l --block-size=k#大小
    shutdown命令：
        shutdown -h now     立刻关机，其中now相当于时间为0的状态
        shutdown -h 20:25    系统在今天的20：25分会关机
        shutdown -r now     系统立刻重新启动
        shutdown -r +30 &#39;The system willreboot&#39;  再过30分钟系统会自动重启，并显示后面的信息
    rmdir命令:
        rmdir -p 路径：递归删除目录
        mkdir -p 路径：递归创建目录
    rm命令:
        rm -rf 文件夹或文件路径
    cp命令:
        -r 递归复制文件和文件夹
    打包与压缩：
        gzip命令:
            gzip readme.txt file1  打包文件
            gzip -d readme.txt    解压文件  后缀为.gz
            bzip2 file1    打包文件
            bzip2 -d file1 解压文件   后缀为.bz2
    tar打包命令:
        # tar -cf all.tar *.jpg        这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。
        # tar -rf all.tar *.gif        这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去，-r 是表示增加文件的意思。
        # tar -uf all.tar logo.gif      这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。
        # tar -tf all.tar             这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。
        # tar -xf all.tar            这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。
        调用gzip打包:
            # tar -czf all.tar.gz *.jpg        这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。
            # tar -xzf all.tar.gz            这条命令是将上面产生的包解开。
        调用bzip2打包:
            # tar -cjf all.tar.bz2 *.jpg    这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2
            # tar -xjf all.tar.bz2            这条命令是将上面产生的包解开。
            -v查看详情
    zip解压和压缩：
        -r 打包后文件名 打包的文件  递归压缩
        解压 unzip 打包后文件名 -d 解压到的文件路径
        
1、设置ssh开机自启动
    sudo systemctl enable ssh
    说明：sudo是提升权限，systemctl是服务管理器，enable是systemctl
    的参数，表示启用开机自动运行，ssh是要设置的服务名称。
    设置成功后，可以用chkconfig查看一下ssh的开机启动状态 ，on表示已设置开机自启动。
    2、ssh禁用开机自启动
    sudo systemctl disable ssh
    说明：sudo是提升权限，systemctl是服务管理器，disable是systemctl
    的参数，表示禁止开机运行，ssh是要设置的服务名称。
    
    AuthorizationRootLogin yes
    修改PermitRootLogin和PubkeyAuthentication两项(第一个是允许root登录，第二个是允许ssh公钥认证登录)
        
man命令使用方法：
    man的级别
        1    系统命令
        2    系统接口
        3    函数库
        4    特殊文件，比如设备文件
        5    文件
        6    游戏
        7    系统的软件包
        8    系统管理命令
        9    内核
vim命令用法：
    在文档中向后查找单词：/pattern，按n查找下一处，按N查找上一处。
    在文档中向前查找单词：？pattern，按n查找下一处（向前），按N查找上一处。
    精确匹配：/\&lt;pattern&gt;。
    高亮单词：gd
    文档中替换：%s/pattern/new_pattern/gc，%表示全部文档，g表示全局替换，c表示替换前需要确认，所有的pattern会被替换为new_pattern　
    
    光标所在行：dd
    删除从光标所在行开始的n行：dnd，比如：d2d 会删除光标所在行及其后1行，共删除2行
    u   撤销上一步的操作，Ctrl+r 恢复上一步被撤销的操作
    
df命令:
    df -f 展现磁盘大小
先查看下是否有磁盘没有分区
    fdisk -l
    fdisk /dev/sdb
格式化已经分好的区 
    # mkfs -t ext4 /dev/sdb1 
1，将磁盘上原有的分区删除掉： 
    进入：#parted /dev/sdb 
    查看：（parted）p 
    删除：（parted）rm 1 
    （parted）rm 2
    
free命令:
    free -m 查看内存大小
du命令:
    方便阅读的格式显示test目录所占空间情况：# du -h test
date设置时间命令:
    date -s &quot;2012-12-12 10:10:10&quot;
    date -d &quot;+%d/%m/%Y %H:%M:%S&quot;
    hwclock获取时间硬件RTC时间:
        hwclock -w将系统时间保存到硬件RTC
    cal命令:
        cal -1当前月份日历
        cal -y 输出某一年份日历
        
Linux上的kvm虚拟机安装方法：
    
    1. 查看系统版本：
        cat /etc/centos-release
    2.检查CPU：
        cat /proc/cpuinfo | egrep &#39;vmx|svm&#39;
    3. 查看是否加载KVM
        lsmod | grep kvm
        这表明已经加载，如果没有加载则执行以下命令加载KVM
            modprobe kvm
    4. 关闭selinux
        setenforce 0 或者 vim /etc/sysconfig/selinux 修改SELINUX=disabled
    5. 安装KVM相关软件包：
        yum install qemu-kvm qemu-img \ virt-manager libvirt libvirt-python virt-manager \ libvirt-client virt-install virt-viewer -y
        qemu-kvm: KVM模块
        libvirt: 虚拟管理模块
        virt-manager: 图形界面管理虚拟机
        virt-install: 虚拟机命令行安装工具
    6. 启动libvirt并设置开机自启动
        systemctl start libvirtd
        systemctl enable libvirtd
    7. 使用图形化界面安装虚拟机
            df -hT
    8.进入图形化：
        virt-manager
    配置桥接网卡：
        #cat /etc/sysconfig/network-scripts/ifcfg-ens33
        TYPE=Ethernet
        #PROXY_METHOD=none
        #BROWSER_ONLY=no
        BOOTPROTO=dhcp
        #BOOTPROTO=static
        DEFROUTE=yes
        IPV4_FAILURE_FATAL=no
        IPV6INIT=yes
        IPV6_AUTOCONF=yes
        IPV6_DEFROUTE=yes
        IPV6_FAILURE_FATAL=no
        IPV6_ADDR_GEN_MODE=stable-privacy
        NAME=ens33
        #UUID=6ede430a-efac-4c08-9df1-39ffc0aa656c
        DEVICE=ens33
        ONBOOT=yes
        BRIDGE=br0
        #cat /etc/sysconfig/network-scripts/ifcfg-br0
        #TYPE=Ethernet
        TYPE=Bridge
        #PROXY_METHOD=none
        #BROWSER_ONLY=no
        BOOTPROTO=dhcp
        #BOOTPROTO=static
        DEFROUTE=yes
        IPV4_FAILURE_FATAL=no
        IPV6INIT=yes
        IPV6_AUTOCONF=yes
        IPV6_DEFROUTE=yes
        IPV6_FAILURE_FATAL=no
        IPV6_ADDR_GEN_MODE=stable-privacy
        #NAME=ens33
        NAME=br0
        #UUID=6ede430a-efac-4c08-9df1-39ffc0aa656c
        #DEVICE=ens33
        DEVICE=br0
        ONBOOT=yes
</code></pre>
<p>​<br>​    乱码设置：<br>​        Options-&gt;Session Options…-&gt;Appearance-&gt;SercureCRT的编码格式是“Default”改为“UTF-8”<br>​    网卡配置：<br>​        网关配置：/etc/resolv.conf<br>​        cd /etc/sysconfig/network-scripts/ vi ifcfig-ens33进入<br>​            #HWADDR = …..<br>​            BOOTPROTO=static<br>​            ONBOOT=yes<br>​            IPADDR=192.168.27.6<br>​            NETMASK=255.255.255.0<br>​            GETEWAY=192.168.27.2<br>​            DNS1=114.114.114.114<br>​        service network restart 重启服务<br>​        关闭防火墙：<br>​            service iptables stop重新开机启动<br>​            chkconfig iptables off开机不启动<br>​            chkconfig或者systemctl list-unit-files列出服务清单<br>​            systemctl stop firewalld.service 关闭防火墙systemctl disable firewalld.service永久关闭<br>​            查看防火墙状态：systemctl status firewalld<br>​        关闭selinux：<br>​            cd /etc/selinux 然后 vi config 修改selinux = disable<br>​            vi /etc/hosts 添加映射<br>​        设置主机名：<br>​            vi /etc/sysconfig/network<br>​        查看硬件地址：<br>​            虚拟机，net，高级<br>​            cd /etc/udev/rules.d 删除70-persistent…<br>​        windows配置主机映射：<br>​            windwos-&gt;system32-&gt;drivers-&gt;etc-&gt;host<br>​<br>        用户不能使用sudo：vi /etc/sudoers           xxx ALL=(ALL) ALL (这里的xxx是你的用户名)<br>    安装jdk：<br>        安装jdk方法:<br>            /home/jdk1.8.0_11<br>            /home/jdk1.8.0_11/jre<br>            /home/jdk1.8.0_11/bin<br>            /home/jdk1.8.0_11/lib;<br>            /home/jdk1.8.0_11/jre/lib<br>        安装tengine：<br>            ./configure -prefix=/opt/sxt/nginx安装的目录</p>
<pre><code>一个系统可以创建多个网卡：
    vim /etc/sysconfig/network-scripts/ifcfg-ens33或/etc/sysconfig/network-scripts/ifcfg-ens33:0
    改device和ipaddr
</code></pre>
<p>yum源配置:<br>​    先进入yum源配置目录<br>​    cd /etc/yum.repos.d<br>​    备份系统自带的yum源<br>​    mv CentOS-Base.repo CentOS-Base.repo.save<br>​    下载其他更快的yum源<br>​    中科大的yum源：<br>​    wget <a target="_blank" rel="noopener" href="http://centos.ustc.edu.cn/CentOS-Base.repo">http://centos.ustc.edu.cn/CentOS-Base.repo</a><br>​    163的yum源：<br>​    wget <a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS-Base-163.repo">http://mirrors.163.com/.help/CentOS-Base-163.repo</a><br>​    sohu的yum源<br>​    wget <a target="_blank" rel="noopener" href="http://mirrors.sohu.com/help/CentOS-Base-sohu.repo">http://mirrors.sohu.com/help/CentOS-Base-sohu.repo</a><br>​    更新完yum源后，建议更新一下，使操作立即生效<br>​    yum makecache<br>​    CentOS 7<br>​    wget -O /etc/yum.repos.d/CentOS-Base.repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a><br>​    或者<br>​    curl -o /etc/yum.repos.d/CentOS-Base.repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a><br>​    curl -O 网址<br>​    3、之后运行yum makecache生成缓存</p>
<p>shell脚本编程开始：<br>    shell bash：<br>        解释器，启动器<br>        解释器：<br>            用户交互输入<br>            文本文件输入<br>    脚本本质：<br>        /bin/bash<br>        /usr/bin/python</p>
<pre><code>重定向：
        ls -l /etc / 1&gt;ls.txt 2&gt;ls.txt  输出到文件，&gt;&gt;追加,&gt;&amp; 1或文件输出到屏幕
        read sxt 或 read sxt 0&lt;&lt;OOXX遇到OOXX就停，操作输入流,sxt为变量
        exec  8&lt;&gt; /dev/tcp/www.baidu.com/80,写入文件，cat 0&lt;&amp; 8接收响应
        文件描述符关闭：exec fd&lt;&amp;-其中fd为文件描述符的数字
        
shell变量：
        打印echo $a
        help 命令
        #!/bin/bash开头
        $取值
        export定义变量    var01=`echo $(echo $sxt)`命令替换,先执行命令，取结果赋值
        unset取消变量    自增((a++))和c=$((a+b))算数表达式 test 3 -gt大于 8或者[ ! 3 -gt 8 ]
        set查看变量        $#参数$?上个命令结果
        if 条件; then echo &quot;hello&quot;;else echo &quot;no ok&quot;; fi
        for ((i=0;i&lt;10;i++))word;do echo $i; done for i in word;do echo $i done
        while ls -l /god command ; do echo &quot;ok&quot;;rm -fr /god;done
            打印错误：
                old=$IFS换行，空格，制表符
                IFS=$&#39;\n&#39;全部替换
</code></pre>
<p>​<br>​            后台运行：<br>​                1. command &amp; ： 后台运行，你关掉终端会停止运行<br>​                2. nohup command &amp; ： 后台运行，你关掉终端也会继续运行<br>​<br>                执行.sh文件：当前source *.sh直接执行(在当前bash环境下读取并执行FileName中的命令。)<br>                bash FileName(在当前bash环境下读取并执行FileName中的命令)<br>                ./FileName 打开一个子shell来读取并执行FileName中命令。<br>            &amp; 将指令丢到后台中去执行<br>            [ctrl]+z 將前台任务丟到后台中暂停<br>            jobs 查看后台的工作状态<br>            fg %jobnumber 将后台的任务拿到前台来处理<br>            bg %jobnumber 将任务放到后台中去处理<br>            kill 管理后台的任务<br>            bash sh02.sh加上&amp;以后台方式启动,创建子进程，sleep(20)睡觉</p>
<p>​<br>​<br>​    docker安装：<br>​        卸载已经安装的软件<br>​            sudo yum remove docker docker-client docker-client-latest docker-common docker-latestdocker-latest-logrotate docker-logrotatedocker-engine<br>​            设置仓库：<br>​                sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br>​            使用以下命令来设置稳定的仓库。<br>​                sudo yum-config-manager –add-repo <a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/docker-ce.repo%E6%88%96https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo%E6%88%96http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo或https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo或http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br>​        安装 Docker Engine-Community<br>​            sudo yum install docker-ce docker-ce-cli containerd.io<br>​        要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：<br>​            1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。<br>​            yum list docker-ce –showduplicates | sort -r<br>​            2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。<br>​            sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io<br>​            3.启动 Docker。<br>​            sudo systemctl start docker<br>​            4.通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。<br>​            sudo docker run hello-world<br>​<br>        退出容器的 tty。<br>            exit<br>        现在，我们要去保存在Fedora实例里做的修改。要做到这个，我们首先需要知道实例的容器ID。而为了得到ID，我们又需要运行以下命令（LCTT 译注：在容器外执行该命令）。<br>            docker ps -a<br>        然后，我们会保存这些改变为一个新的镜像，请运行以下命令。<br>            docker commit c16378f943fe fedora-httpd<br>        这里，修改已经通过使用容器ID保存起来了，镜像名字叫fedora-httpd。为了确认新的镜像是否在运行，我们将运行以下命令。<br>            docker images</p>
<pre><code>    查询容器进程：docker ps -a 关闭:docker stop id 打开:docker start id
    删除容器：docker rm id
    删除镜像：docker rmi id
    启动镜像：docker run my/python:v1或者docker run -it my/python:v1 /bin/bash
    通过inspect查看一下网络信息：docker inspect web容器名#查看ip
</code></pre>
<p>​<br>​        拉取镜像并运行：docker run -p 80 –name web -it centos /bin/bash<br>​        -d :代表后台运行容器，返回容器ID<br>​        –name: 自定义容器的名称，不加这命令docker会随便给一个名给你，所以建议打上这命令<br>​        -p :代表映射的端口 本地端口:镜像的默认端口（注意，每个软件默认端口是不同的）<br>​        -e: 配置mysql的root密码<br>​        -i: 以交互模式运行容器，通常与 -t 同时使用；<br>​        -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>​        -P: 随机端口映射，容器内部端口随机映射到主机的高端口<br>​        –volume , -v: 绑定一个卷<br>​        获取nginx镜像：docker search nginx<br>​            docker pull nginx:latest<br>​        安装完成后，我们可以使用以下命令来运行 nginx 容器：<br>​        docker run –name nginx-test -p 8080:80 -d nginx<br>​        ctrl+p,ctrl+q退出容器而不停止容器运行，从docker回到Linux上<br>​<br>        把当前容器作为镜像提交本地仓库：<br>            docker commit （containerid） （images）<br>        登陆阿里云镜像仓库：docker login –username=用户名 registry.cn…#镜像名字<br>        推送到远程仓库：docker push ….<br>        然后阿里云控制台查看。</p>
<pre><code>    搭建镜像仓库：
        首先，下载Registry镜像并启动：
            docker pull registry
        然后，运行一个Registry镜像仓库的容器实例：
            docker run -d -v /edc/images/registry:/var/lib/registry -p 5000:5000 --restart=always --name xdp-registry registry
        最后，在客户端查看镜像仓库中的所有镜像
            curl http://your-server-ip:5000/v2/_catalog
        1.2 上传镜像：
            首先，为了让客户端服务器能够快速地访问刚刚在服务端搭建的镜像仓库（默认情况下是需要配置HTTPS证书的），这里简单在客户端配置一下私有仓库的可信任设置让我们可以通过HTTP直接访问：# vim /etc/docker/daemon.json
            &#123; 
                &quot;insecure-registries&quot; : [ &quot;your-server-ip:5000&quot; ] #这里的&quot;your-server-ip&quot;请换为你的服务器的外网IP地址
            &#125;
        重新启动docker服务：# systemctl restart docker
        其次，为要上传的镜像打Tag: docker tag your-image-name:tagname your-server-ip:5000/your-image-name:tagname
        最后，开始正式上传镜像到服务端镜像仓库
            docker push your-registry-server-ip:5000/your-image-name:tagname
        下载镜像就很简单了，使用pull命令即可：
            docker pull your-server-ip:5000/your-image-name:tagname
        如果想要知道要下载的镜像都有哪些tag（或版本），可以通过下面这个api来获取：
            curl http://your-server-ip:5000/v2/your-image-name/tags/list
    删除docker:
        sudo yum remove docker \
            docker-client \
            docker-client-latest \
            docker-common \
            docker-latest \
            docker-latest-logrotate \
            docker-logrotate \
            docker-engine

定时任务：
    设置系统时间：
        date -s &quot;20140712 18:30:50&quot;
        我们会先设日期
        date -s 20140712
        再设时间
        date -s 18:30:50
        
    1. cron服务【Ubuntu环境】
        查看cron状态
        1sudo  service cron status　
        开启cron
        1sudo /etc/init.d/cron start
        关闭cron
        1sudo /etc/init.d/cron stop
        重启cron
        1sudo /etc/init.d/cron restart
        2. crontab用法
            crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。 
            crontab –l : 显示 crontab 文件。 
            crontab -r : 删除 crontab 文件。
            crontab -ir : 删除 crontab 文件前提醒用户。
        格式如下： 
        minute hour day-of-month month-of-year day-of-week commands   
        
        合法值为：00-59 00-23 01-31 01-12 0-6 (0 is sunday) 
        除了数字还有几个特殊的符号：&quot;*&quot;、&quot;/&quot;和&quot;-&quot;、&quot;,&quot;
        *代表所有的取值范围内的数字
        &quot;/&quot;代表每的意思,&quot;/5&quot;表示每5个单位
        &quot;-&quot;代表从某个数字到某个数字
        &quot;,&quot;分开几个离散的数字
        每天早上6点
        0 6 * * * echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。
        每小时（第一分钟）执行/etc/cron.hourly内的脚本
        01 * * * * root run-parts /etc/cron.hourly
</code></pre>
<p>​        </p>
<p>课堂笔记：<br>    第3章 NumPy 数据分析：<br>        numpy.sum(a,axis=None,dtype=None)默认整个数组求和<br>        a[4][5]的axis=1对每行的五个个数求和,axis=0对4的个数求和。4为零轴，5位1轴。</p>
<pre><code>    numpy.mean(a,axis=None,dtype=None)
    np.mean()用于求数组的平均值，也可以通过axis参数指定求平均值的轴，通过out参数指定输出数组。
    
    np.average(data, axis=1, weights=[1./4, 3./4])
    np.average(a,axis=None,weight=None,returned=False)
    和数学上的概念一致，这里的average函数需要指定的weights是一个和所需计算数组（或数组维度）长度一致的数组，如果不指定，则默认为1（变成算术平均）

    np.std(a,axis=None,dtype=None,ddof=0)
    这里的ddof表示自由度，默认为0，如果你需要计算的是样本的方差或标准差，ddof取值应该为1
        a = np.array([1, 2, 3, 4])
        print(np.std(a))     #使用总体：标准差为1.118033988749895
        print(np.std(a， ddof=1))     #使用样本，标准差为1.2909944487358056
        根据公式自行验证：
                b = a – np.mean(a)
                print((np.sum(b*b) / 3) ** 0.5)

    转置函数transpose():
        a.transpose((1,0))
        这里的a是一个要转换的数组, axes是轴向的转换，numpy的数组按0轴、1轴、2轴进行区分，这里假设是一个三维数组，如果要将0轴和2轴进行交换，则使用 numpy.transpose(a, (2, 1, 0))
    
    np.堆叠函数hstack和vstack
    np.hstack((arr1,arr2))
    np.vstack((arr1,arr2))
    这两个函数的主要作用就是进行数组的组合，hstack在水平方向平铺（也就是沿着1轴），vstack在垂直方向上堆叠（也就是沿着0轴）

    np.min(axis=None), max(axis=None), ptp(axis=None)
    这里的ptp表示求出的是最大值和最小值的差值，3个函数都拥有axis这个参数，可以指定沿着哪个轴求对应的值,如果是多维数组，则返回的是一个对应长度的一维数组

    np.argmax(axis=None)和argmin(axis=None)
    这两个函数可以求得最大值和最小值的下标，指定axis参数的时候，其返回的是对应轴向上构成的数组的下标。不指定的话，返回的是对应数组平坦化（ravel操作后)对应的下标
    
    可以通过unravel_index()将一维下标转换为多维数组中的下标，它的第一个参数为一维下标值，第二个参数是多维数组的形状
    idx = np.unravel_index(2, a.shape)
    
    np.median(a,axis=0)
    用median()可以获得数组的中值，即对数组进行排序之后，位于数组中间位置的值，当长度是偶数时，得到正中间两个数的平均值。它也可以指定axis和out参数： 
    
    unique()
    np.unique(a, return_index=True)
    返冋其参数数组中所有不同的值，并按从小到大的顺序排列。它有两个可选参数：
    retum_index : Ture表示同时返回原始数组中的下标。retun_inverse: True表示返冋重建原始数组用的下标数组。

    bincount()
    np.bincount(a,weight)
    对整数数组中各个元素出现的次数进行统计，它要求数组中所有元素都是非负的。其返回数组中第i个元素的值表示整数i在参数数组中出现的次数。

    poly1d()
    例如f(x) = x3 -2x + 1可以用下面的数组表示，其中a[0]是最高次的系数，a[-1]是常数项，注意x2的系数为0。
    a= np.array([1.0, 0, -2, 1])
    p = np.poly1d(a)
    p(np.linspace(0,1, 5))
    array([ 1., 0.515625,    0.125    , -0.078125, 0. ])
    可以用poly1d()将系数转换为poly1d(一元多项式)对象，此对象可以像函数一样调用，它返回多项式函数的值：
    
    多项式函数的根可以使用roots()函数计算：
        r = np.roots(p)
        array([-1.61803399,    1.    , 0.61803399])

    而poly()函数可以将根转换冋多项式的系数：
        np.poly(r)
        array([ 1. 00000000e+00, 9.99200722e-16, -2. 000000000e+00 , 1.00000000e+00])

    二项分布函数random.binomial:
        binomial(n, p, size=None)
        np.random.binomial(2,0.9,1000000)==1，找两个井，每次找不到油井的概率为0.9，只找到一口井有油的概率
        表示对一个二项分布进行采样（size表示采样的次数），参数n表示：在总体N中，某事件n发生的次数。p表示n发生的概率，返回结果为一个数组或整数（当size不给值得时候），表示的都为每次采样时，n发生的次数的随机值（取值范围为0-n）
        在抛硬币实验中，假设我们一次抛掷的是3个硬币，要得到1个正面和2个反面的概率为多少呢？
        sum(np.random.binomial(3,0.5,5000)==1)/5000
    
    数据可视化化plot：
        导入包：import matplotlib.pyplot as plt
        plt.plot(x, y,  ls=&quot;-&quot;, lw=2, label=&quot;plot figure&quot;)
        x: x轴上的数值
        y: y轴上的数值
        ls：折线图的线条风格
        lw：折线图的线条宽度
        label：标记图内容的标签文本
        
    安装第三方库：
        pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib
        
    超几何分布:
        Numpy中提供random.hypergeometric  函数用于生成超几何分布： 
        np.random.hypergeometric(ngood,nbad,nsample,size=None)
        其中 ngood：表示总体中一种种类的数量
        nbad：表示总体中另一种种类的数量
        nsample：表示从总体中取样的个数
        size: 表示重复实验的次数
        其返回的是一个值或数组（取决于size)，得到的是从总体中按照nsample抽取后，ngood的数量（nbad=nsample - ngood）
        np.random.hypergeometric(7,3,4,1000) print(sum(s==2))

    Numpy中的泊松分布:
        np.random.poisson(lam=1.0,size=None)
        这里的lam就是λ 或者均值，size是重复执行的次数，返回的结果为一个具有泊松分布的数组（即围绕均值的数据）

    Numpy中的中的正态分布函数
        np.random.lognormal(mean=0.0,sigma=1.0,size=None)

    取消科学计数法：
        import numpy as np
        np.set_printoptions(suppress=True, threshold=np.nan)
        suppress=True 取消科学记数法
        threshold=np.nan 完整输出（没有省略号）
    np列表添加：
        a=np.array([row2])
        a=np.append(a,[row2],axis=0)#垂直添加
        a=np.append(a,[row2],axis=1)#水平添加    
    
xlrd库用法：
    读取数据：
        wb = xl.open_workbook(r&#39;C:\Users\Administrator\Desktop\新建文件夹\期末成绩.xls&#39;)#打开文件
        print(wb.sheet_names())#获取页数
        sheet1=wb.sheet_by_index(0)#获取目标页
        rowNum=sheet1.nrows    #获取行
        colNum=sheet1.ncols     #获取列
        print(rowNum)
        print(colNum)
        s=sheet1.cell(0,0).value.encode(&#39;utf-8&#39;)#设置编码
        print(sheet1.cell(1,2).ctype)#1 ctype : 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error
        print(s)
        #获取整行和整列的数据
        #第二行数据
        row2 = sheet1.row_values(1)
        #第二列数据
        cols2 = sheet1.col_values(2)
        d = xl.xldate_as_tuple(sheet1.cell_value(1,1),wb.datemode)
        print(d)#d为元组
        数值转换：a.astype(float)
        
xlwt用法：
    #初始化样式
    style = xlwt.XFStyle()
    #创建字体
    font = xlwt.Font()
    font.bold = bold
    font.colour_index = 4
    font.height = height
    font.name =name
    style.font = font
    return style
    写入数据：
        f = xlwt.Workbook()
        #创建sheet1
            sheet1 = f.add_sheet(u&#39;sheet1&#39;,cell_overwrite_ok=True)
            row0 = [u&#39;业务&#39;,u&#39;状态&#39;,u&#39;北京&#39;,u&#39;上海&#39;,u&#39;广州&#39;,u&#39;深圳&#39;,u&#39;状态小计&#39;,u&#39;合计&#39;]
            column0 = [u&#39;机票&#39;,u&#39;船票&#39;,u&#39;火车票&#39;,u&#39;汽车票&#39;,u&#39;其他&#39;]
            status = [u&#39;预定&#39;,u&#39;出票&#39;,u&#39;退票&#39;,u&#39;业务小计&#39;]
            for i in range(0,len(row0)):
            sheet1.write(0,i,row0[i],set_stlye(&quot;Time New Roman&quot;,220,True))
            i,j = 1,0
            while i &lt;4*len(column0): #控制循环：每次加4
            #第一列
            sheet1.write_merge(i,i+3,0,0,column0[j],set_stlye(&#39;Arial&#39;,220,True))
            #最后一列
            sheet1.write_merge(i,i+3,7,7)
            i += 4
            sheet1.write_merge(21,21,0,1,u&#39;合计&#39;,set_stlye(&quot;Time New Roman&quot;,220,True))

            i=0
            while i&lt;4*len(column0): #控制外层循环：每次加4
            for j in range(0,len(status)): #控制内层循环：设置每一行内容
            sheet1.write(i+j+1,1,status[j])
            i += 4
            #创建sheet2
            sheet2 = f.add_sheet(u&#39;sheet2&#39;,cell_overwrite_ok=True)
            row0 = [u&#39;姓名&#39;,u&#39;年龄&#39;,u&#39;出生日期&#39;,u&#39;爱好&#39;,u&#39;关系&#39;]
            column0 = [u&#39;UZI&#39;,u&#39;Faker&#39;,u&#39;大司马&#39;,u&#39;PDD&#39;,u&#39;冯提莫&#39;]

            #生成第一行
            for i in range(0,len(row0)):
            sheet2.write(0,i,row0[i],set_stlye(&#39;Times New Roman&#39;,220,True))

            #生成第一列
            for i in range(0,len(column0)):
            sheet2.write(i+1,0,column0[i],set_stlye(&#39;Times New Roman&#39;,220,True))
            f.save(&#39;data.xls&#39;)
</code></pre>
<p>​<br>​    pandas用法:<br>​        Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组 与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series:<br>​        导入包：<br>​            from pandas import Series, DataFrame<br>​            import pandas as pd<br>​        Series数据结构：<br>​            用法：obj = Series([4, 7, -5, 3])<br>​            标签 数组<br>​            0    4<br>​            1    7<br>​            2   -5<br>​            3    3<br>​            obj.values查看值<br>​            obj.index查看索引<br>​            另一种方式：<br>​                obj2 = Series([4, 7,-5,3], index=[‘d’,’b’,’a’,’c’])<br>​                obj2.index#打印结果：Index([u’d’, u’b’, u’a’, u’c’], dtype=’object’)<br>​            修改索引：obj.index = [‘Bob’, ‘Steve’, ‘Jeff’, ‘Ryan’]<br>​            可做操作：<br>​                切片：<br>​                    obj2[[‘c’,’a’,’d’]]#显示值<br>​                    obj2[obj2 &gt; 0]<br>​                obj2*2<br>​                判断是否索引有值：’b’ in obj2<br>​                obj3 = Series(字典)<br>​                obj4 = Series(字典,index=索引)<br>​                pd.isnull(obj4) # Series也有类似的实例方法:#obj4.isnull()或者pd.notnull(obj4) 返回true和false<br>​                obj4.index.name = ‘state’#索引名字   obj4.name = ‘population’#整个列表名字<br>​            重新命名索引：<br>​                obj2 = obj.reindex([‘a’, ‘b’, ‘c’, ‘d’, ‘e’])或obj.reindex([‘a’, ‘b’, ‘c’, ‘d’, ‘e’], fill_value=0)<br>​            填充：<br>​                obj3.reindex(range(6), method=’ffill’)#bfill向后填充<br>​<br>        DataFrame数据结构：<br>            具体形式：<br>                data={‘state’:列表,’year’:列表,’pop’:列表}<br>                frame = DataFrame(data)<br>                基础属性：<br>                    values   元素<br>                    index    索引<br>                    columns    列名<br>                    dtypes    类型<br>                    size    元素个数<br>                    ndim    维度数<br>                    shape    数据形状<br>                DataFrame(data, columns=[‘year’, ‘state’, ‘pop’])#按顺序排列<br>                通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series:<br>                    frame2[‘state’]<br>                    frame2.ix[‘three’]#访问行<br>                如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：<br>                    val = Series([-1.2, -1.5, -1.7],index=[ ‘two’, ‘four’, ‘five’])<br>                    frame2[‘debt’] = val<br>                删除列和创造列：<br>                    frame2[‘eastern’] = frame2.state == ‘Ohio’<br>                    del frame2[‘eastern’]<br>                每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的 常见问题：</p>
<pre><code>            DataFrame的reindex用法：
                frame = DataFrame(np.arange(9).reshape((3, 3))#二维数组, index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]#行,columns=[ &#39;Ohio&#39;, &#39;Texas&#39;, &#39;California&#39;]#列)
                frame2 = frame.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
                frame.reindex(columns=列表)
                可以一条语句： frame.ix[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], states]
                参数           说明
                index           用作索引的新序列。既可以是index实例，也可以是其他序列型的Python数据结构。Index
                                    会被完全使用，就像没有任何复制一样。
                method         插值（填充）方式。
                fill_value       在重新索引的过程中，需要引入缺失值时使用的替代值 .   
                limit           前向或后向填充时的最大填充量.
                level           在Multiindex的指定级别上匹配简单索引，否则选取其子集
                copy             默认为True，无论如何都复制；如果为False，则新旧相等就不复制
            
            切片操作：
                data[data[&#39;three&#39;] &gt; 5]
                
            Dataframe的loc和iloc访问：
                DataFrame.loc[行索引名称或条件, 列索引名称]
                iloc和loc区别是iloc接收的必须是行索引和列索引的位置：
                    DataFrame.iloc[行索引位置, 列索引位置]#必须是数字
                data.loc[&#39;a&#39;]  data.iloc[0] #取第一行数据，索引为&#39;a&#39;的行就是第一行，所以结果相同
                data.loc[:,[&#39;A&#39;]]    data.iloc[:,[0]]    取&#39;A&#39;列所有行，多取几列格式为 data.loc[:,[&#39;A&#39;,&#39;B’]]#取第0列所有行，多取几列格式为 data.iloc[:,[0,1]]
                取值：
                data=data[&#39;列名&#39;][:5]  #某列的所有行
                data.ix[2:6,5]#从2到6的位置为5的数。
                data=data[data[&#39;列名&#39;]==&#39;458&#39;].values([1,5])#id=458的列数据为
                data=data[data[&#39;列名&#39;]==某个数字,&#39;列名&#39;]#返回某个数字。
            
            pd.insert(0,&#39;小说ID号&#39;,np.array(list1))#插入列数据
            
        文本的读取：
            使用read_table来读取文本文件。
            pandas.read_table(文件路径, sep=&quot;分隔符，默认,&quot;, header=’某行数据做列名，默认infer，自动识别’, names=None#列表名, index_col=None表示列索引位置 sequence表示多重索引, dtype=None, engine=None#解析引擎,默认c, nrows=None#读取前n行)
            使用read_csv函数来读取csv文件。
            pandas.read_csv(filepath_or_buffer, sep=’\t’, header=’infer’, names=None, index_col=None, dtype=None, engine=None, nrows=None)
            pandas.read_excel(文件路径)和read_table一样
        2.Excel文件储存
            将文件存储为Excel文件，可以使用to_excel方法。其语法格式如下。
            DataFrame.to_excel(excel_writer=None, sheetname=None’, na_rep=”, header=True, index=True, index_label=None, mode=’w’, encoding=None)
            to_csv方法的常用参数基本一致，区别之处在于指定存储文件的文件路径参数名称为excel_writer，并且没有sep参数，增加了一个sheetnames参数用来指定存储的Excel sheet的名称，默认为sheet1。
            写入文件：
                frame.to_csv(&quot;./test.csv&quot;,mode=&#39;a&#39;,index=False,header=None)#不要列名和行索引
                
        函数名称：
            .min最小    median中位数    var方差     max最大值     ptp极差    std标准差    cov协方差
            .mean均值
            举列子:detail[&#39;列名&#39;].mean()计算某列的均值
        pandas的describe：的出数据框所有数值特征的非空数组，均值。
        pandas用法：
            data[&#39;payment&#39;]=data[&#39;counts&#39;]*data[&#39;amount&#39;]#对应的位置上相乘。
            
            pandas删除数据：
                data.drop(labels=&#39;列名&#39;,axis=1,inplce=True)#删除类索引值。
                data.drop(labels=range(1,11),axis=0)#删除行
                data[&#39;amount&#39;]#可以看成numpy。.mean()=np.mean(data[&#39;amounts&#39;])
                
        pandas处理时间列数据：
            order[&#39;lock_time&#39;]=pd.to_datatime(order[&#39;lock_time&#39;])#转化
            year1=[i.year for i in order[&#39;lock_time&#39;]]#取出数据，还有其他的数据值，month,day,hour,minute,second,date
            data.weekday_name[:5]#属性值
        pandas的groupby用法：
            datagroup=data[[&#39;列名&#39;,&#39;列名&#39;]].groupby(by=&#39;order_id&#39;)
            data.mean().head()#前五行均值
        pandas添加数据：
            df1.insert(2#行,&#39;birth&#39;列,[&#39;1995-07-01&#39;,&#39;1998-09-04&#39;,&#39;1993-11-03&#39;,&#39;1994-04-17&#39;]#值)
            添加一行：df1=df1.append(new,ignore_index=True)#ignore_index=True,表示不按原来的索引，从0开始自动递增
        
python加参数运行（sys）:
    import sys
    a=eval(sys.argv[1])
    b=eval(sys.argv[2])
    sys.argv 是命令行参数列表。
    len(sys.argv) 是命令行参数个数。
    注：sys.argv[0] 表示脚本名。
    
matplotlib.pyplot库的用法：
    导入包import matplotlib.pyplot as plt：
        plt.xticks(rotation=270)#旋转270度
        plt.yticks(rotation=270)#旋转270度
        plt.bar(x=all.index,height=all.values)#横轴和纵轴
        # 横向柱状图
        # name_list = all.index
        # num_list = height=all.values
        # plt.barh(range(len(num_list))##横坐标, num_list#纵坐标,tick_label = name_list)
        # plt.show()
        柱状图
        # plt.xticks(rotation=270)#旋转270度
        # plt.bar(x=all.index#x坐标,height=all.values#y坐标)
        # plt.show()
        折线：
            plt.plot(all.index#横坐标,all.values#纵坐标)
            plt.show()
        饼状图：
            # plt.rcParams[&#39;font.sans-serif&#39;]=&#39;SimHei&#39;#设置中文显示
            # plt.figure(figsize=(6,6))#将画布设定为正方形，则绘制的饼图是正圆
            # label=np.array(all.index)#定义饼图的标签，标签是列表
            #explode=[0.01,0.01,0.01]#设定各项距离圆心n个半径
            #plt.pie(values[-1,3:6],explode=explode,labels=label,autopct=&#39;%1.1f%%&#39;)#绘制饼图
            # values=np.array(all.values)
            # plt.pie(values#值,labels=label#标签,autopct=&#39;%1.1f%%&#39;#精确度)#绘制饼图
            # plt.title(&#39;fifa19&#39;)#绘制标题
            # plt.show()
        散点图：
            # plt.rcParams[&#39;font.sans-serif&#39;]=&#39;SimHei&#39;#设置中文显示
            # font = FontProperties(fname=r&quot;C:\Windows\Fonts\simhei.ttf&quot;, size=2)#设置点的风格
            # plt.xlabel(&#39;年龄&#39;)#设置x和y的坐标
            # plt.ylabel(&#39;数量&#39;)
            # plt.title(u&#39;散点图示例&#39;, FontProperties=font)
            # plt.legend()
            # plt.scatter(x=np.array(all.index)#x坐标,y=np.array(all.values)#y坐标, c=&quot;#ff1212&quot;, marker=&#39;o&#39;)
            # #s：点的大小/粗细 标量或array_like 默认是 rcParams[&#39;lines.markersize&#39;] ** 2
            # # c: 点的颜色
            # # marker: 标记的样式 默认是 &#39;o&#39;
            # plt.show()
        直方图：
            plt.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;
            plt.rcParams[&#39;font.size&#39;]=20
            plt.hist(x,bins=201,alpha=0.25)
            #x这个参数是指定每个bin(箱子)分布的数据,对应x轴
            #这个参数指定bin(箱子)的个数,也就是总共有几条条状图
            #normed这个参数指定密度,也就是每个条状图的占比例比,默认为1
            plt.ylabel(&quot;个数&quot;)
            plt.xlabel(&#39;数字&#39;)
            plt.title(&#39;直方图数据分析与展示&#39;)
            plt.show()
        箱线图：
            # 设置图形的显示风格
            plt.style.use(&#39;ggplot&#39;)
            # 设置中文和负号正常显示
            plt.rcParams[&#39;font.sans-serif&#39;] = &#39;Microsoft YaHei&#39;
            plt.rcParams[&#39;axes.unicode_minus&#39;] = False
            # 绘图：整体乘客的年龄箱线图
            plt.boxplot(x = titanic.Age, # 指定绘图数据
                patch_artist=True, # 要求用自定义颜色填充盒形图，默认白色填充
                showmeans=True, # 以点的形式显示均值
                boxprops = &#123;&#39;color&#39;:&#39;black&#39;,&#39;facecolor&#39;:&#39;#9999ff&#39;&#125;, # 设置箱体属性，填充色和边框色
                flierprops = &#123;&#39;marker&#39;:&#39;o&#39;,&#39;markerfacecolor&#39;:&#39;red&#39;,&#39;color&#39;:&#39;black&#39;&#125;, # 设置异常值属性，点的形状、填充色和边框色
                meanprops = &#123;&#39;marker&#39;:&#39;D&#39;,&#39;markerfacecolor&#39;:&#39;indianred&#39;&#125;, # 设置均值点的属性，点的形状、填充色
                medianprops = &#123;&#39;linestyle&#39;:&#39;--&#39;,&#39;color&#39;:&#39;orange&#39;&#125;
                ) # 设置中位数线的属性，线的类型和颜色
            # 设置y轴的范围
            plt.ylim(0,85)
            # 去除箱线图的上边框与右边框的刻度标签
            plt.tick_params(top=&#39;off&#39;, right=&#39;off&#39;)
            # 显示图形
            plt.show()
            另一种：
                box_1, box_2, box_3, box_4 = data3[&#39;B&#39;], data3[&#39;C&#39;], data3[&#39;D&#39;], data3[&#39;E&#39;]
                labels = &#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;#图例
                plt.boxplot([box_1, box_2, box_3, box_4]#数值,notch=False, labels = labels#标签,patch_artist = False, boxprops = &#123;&#39;color&#39;:&#39;black&#39;,&#39;linewidth&#39;:&#39;2.0&#39;&#125;,
                            capprops=&#123;&#39;color&#39;:&#39;black&#39;,&#39;linewidth&#39;:&#39;2.0&#39;&#125;)
            水平箱线：
                box_1, box_2, box_3, box_4 = data[&#39;收入_Jay&#39;], data[&#39;收入_JJ&#39;], data[&#39;收入_Jolin&#39;], data[&#39;收入_Hannah&#39;]
                plt.figure(figsize=(10,5))#设置画布的尺寸
                plt.title(&#39;Examples of boxplot&#39;,fontsize=20)#标题，并设定字号大小
                labels = &#39;Jay&#39;,&#39;JJ&#39;,&#39;Jolin&#39;,&#39;Hannah&#39;#图例
                #vert=False:水平箱线图；showmeans=True：显示均值
                plt.boxplot([box_1, box_2, box_3, box_4], labels = labels, vert=False,showmeans=True )
</code></pre>
<p>python压缩图片代码：<br>    #压缩图片：<br>    from PIL import Image<br>    #img = ImageGrab.grab()   # 截图<br>    im = Image.open(“C:/Users/Administrator/Desktop/新建文件夹 (2)/6.1231.png”)<br>    #img_deal = im.resize((int(im.size[0]*0.8),int(im.size[1]*0.8)),Image.ANTIALIAS) # 转化图片大小<br>    img_deal = im.convert(‘RGB’) # 保存为.jpg格式才需要<br>    img_deal.save(“beautiful.jpg”,quality=10,compre_level=100)<br>    #打水印<br>    # from PIL import Image,ImageDraw,ImageFont<br>    # font=ImageFont.truetype(“simsun.ttc”,34)#字体，字号<br>    # im1=image.open(文件路径)<br>    # draw=ImageDraw.Draw(im1)#打水印的图片<br>    # draw.text((160,500),”天若有情”,(250,0,0),font=font)#位置，文字，颜色，字体<br>    # im1.save(‘路径’)#保存<br>    # im1.show()#展示图片</p>
<p>机器学习基础：<br>    机器学习公式：<br>        y=(y^-b-wx)<strong>2/n#对w求导，对b求导，可以得值。<br>        y=b+wx+w1*x</strong>2…… </p>
<pre><code>    #数据有理化
    mean_data = np.mean(data)  # 18 * 9
    std_data = np.std(data)
    data[j][k]=(data[j][k]-mean_data)/std_data
优化参数：
    Adagrad优化方法:
        lr_b=lr_b + b_grad ** 2
        b=b-lr/np.sqrt(lr_b) * b_grad
        lr_w=lr_w + w_grad ** 2
        w=w-lr/np.sqrt(lr_w) * w_grad #lr为学习率,lr_w为偏导平方的和。w_grad为求得的w的倒数。
        梯度=梯度-梯度/sqrt(t+1)#梯度逐渐减小 w=w-(梯度/方差)*学习 #方差为学习率的方差，可以简化
</code></pre>
<p>谷粒商城:<br>    使用:vagrant安装centos7系统,连接虚拟机,vagrant up命令启动,vagrant ssh连接.</p>
<p>伪数据生成:<br>    rom faker import Factory<br>    fake1 = Factory.create()<br>    from faker import Faker</p>
<pre><code>fake2 = Faker()
fake2.name()
fake = Faker(&quot;zh_CN&quot;)
fake.name()

address 地址
person 人物类：性别、姓名等
barcode 条码类
color 颜色类
company 公司类：公司名、公司email、公司名前缀等
credit_card 银行卡类：卡号、有效期、类型等
currency 货币
date_time 时间日期类：日期、年、月等
file 文件类：文件名、文件类型、文件扩展名等
internet 互联网类
job 工作
lorem 乱数假文
misc 杂项类
phone_number 手机号码类：手机号、运营商号段
python python数据
profile 人物描述信息：姓名、性别、地址、公司等
ssn 社会安全码(身份证号码)
user_agent 用户代理

fake.country()  # 国家
&#39;奥地利&#39; 
fake.city()  # 城市
&#39;郑州市&#39;
fake.city_suffix()  # 城市的后缀,中文是：市或县
&#39;市&#39;
fake.address()  # 地址
&#39;河北省巢湖县怀柔南宁路f座 169812&#39;
fake.street_address()  # 街道
&#39;邯郸路W座&#39;
fake.street_name()  # 街道名
&#39;合肥路&#39;
fake.postcode()  # 邮编
&#39;314548&#39;
fake.latitude()  # 维度
Decimal(&#39;68.0228435&#39;)
fake.longitude()  # 经度
Decimal(&#39;155.964341&#39;)

fake.name() # 姓名
&#39;单玉珍&#39;
fake.last_name() # 姓
&#39;潘&#39;
fake.first_name() # 名
&#39;琴&#39;
fake.name_male() # 男性姓名
&#39;官平&#39;
fake.last_name_male() # 男性姓
&#39;安&#39;
fake.first_name_male() # 男性名
&#39;文&#39;
fake.name_female() # 女性姓名
&#39;许颖&#39;

fake.ean8()  # 8位条码
&#39;12771363&#39;
fake.ean13()  # 13位条码
&#39;9133134950963&#39;
fake.ean(length=8)  # 自定义位数条码,只能选8或者13
&#39;20417161&#39;

fake.company() # 公司名
&#39;时空盒数字科技有限公司&#39;
fake.company_suffix() # 公司名后缀
&#39;科技有限公司&#39;


fake.credit_card_number(card_type=None) # 卡号
&#39;375325478746231&#39;
fake.credit_card_provider(card_type=None) # 卡的提供者
&#39;VISA 13 digit&#39;
fake.credit_card_security_code(card_type=None)# 卡的安全密码
&#39;450&#39;
fake.credit_card_expire() # 卡的有效期
&#39;04/22&#39;
fake.credit_card_full(card_type=None) # 完整卡信息
&#39;Maestro\n秀芳 商\n502001016117 04/27\nCVV: 144\n&#39;

fake.currency_code()  # 货币代码
&#39;HNL&#39;

fake.date_time(tzinfo=None) # 随机日期时间
datetime.datetime(2001, 3, 18, 17, 57, 44)
fake.iso8601(tzinfo=None) # 以iso8601标准输出的日期
&#39;1973-11-16T22:58:37&#39;

fake.date_time_this_month(before_now=True, after_now=False, tzinfo=None) # 本月的某个日期
datetime.datetime(2017, 11, 1, 14, 33, 48)
fake.date_time_this_year(before_now=True, after_now=False, tzinfo=None) # 本年的某个日期
datetime.datetime(2017, 3, 2, 13, 55, 31)
fake.date_time_this_decade(before_now=True, after_now=False, tzinfo=None)  # 本年代内的一个日期
datetime.datetime(2010, 3, 26, 6, 33, 23)
fake.date_time_this_century(before_now=True, after_now=False, tzinfo=None)  # 本世纪一个日期
datetime.datetime(2015, 7, 21, 19, 27, 53)
fake.date_time_between(start_date=&quot;-30y&quot;, end_date=&quot;now&quot;, tzinfo=None)  # 两个时间间的一个随机时间
datetime.datetime(2005, 12, 3, 17, 17, 15)

fake.timezone() # 时区
&#39;America/Guatemala&#39;
fake.time(pattern=&quot;%H:%M:%S&quot;) # 时间（可自定义格式）
&#39;11:21:52&#39;
fake.am_pm() # 随机上午下午
&#39;PM&#39;
fake.month() # 随机月份
&#39;02&#39;
fake.month_name() # 随机月份名字
&#39;August&#39;
fake.year() # 随机年
&#39;1974&#39;
fake.day_of_week() # 随机星期几
&#39;Sunday&#39;
fake.day_of_month() # 随机月中某一天
&#39;02&#39;
fake.time_delta() # 随机时间延迟
datetime.timedelta(13371, 27637)
fake.date_object()  # 随机日期对象
datetime.date(1983, 1, 26)
fake.time_object() # 随机时间对象
datetime.time(17, 8, 56)
fake.unix_time() # 随机unix时间（时间戳）
1223246848
fake.date(pattern=&quot;%Y-%m-%d&quot;) # 随机日期（可自定义格式）
&#39;1984-04-20&#39;
fake.date_time_ad(tzinfo=None)  # 公元后随机日期
datetime.datetime(341, 9, 11, 8, 6, 9)


fake.file_name(category=&quot;image&quot;, extension=&quot;png&quot;) # 文件名（指定文件类型和后缀名）
&#39;增加.png&#39;
fake.file_name() # 随机生成各类型文件
&#39;提供.pdf&#39;
fake.file_extension(category=None) # 文件后缀
&#39;txt&#39;
fake.mime_type(category=None) # mime-type
&#39;image/png&#39;
</code></pre>
<p>写文件:<br>    #读取excel数据<br>    data.to_excel(“new.xls”, sheet_name=”Student”)<br>    #字典转pandas数组<br>    excelData = {“1”:[“你好”],”2”:[“你好”],”3”:[“你好”],”4”:[“你好”],”5”:[“你好”]}<br>    data = pd.DataFrame(excelData)</p>
<pre><code># 创建一个空的excel文件
nan_excle = pd.DataFrame()
nan_excel.to_excel(path + filename)

# 打开excel
writer = pd.ExcelWriter(path + filename)
#sheets是要写入的excel工作簿名称列表
for sheet in sheets:
　　output.to_excel(writer, sheet_name=sheet,index=False)

# 保存writer中的数据至excel
# 如果省略该语句，则数据不会写入到上边创建的excel文件中
writer.save()
</code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
